<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>简易的reactjs</title>
    <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script>
</head>
<body>
<script type="text/javascript">
    //用来判定两个element需不需要更新
    //这里的key是我们createElement的时候可以选择性的传入的。用来标识这个element，当发现key不同时，我们就可以直接重新渲染，不需要去更新了。
    var _shouldUpdateReactComponent=function(prevElement, nextElement){
        if (prevElement != null && nextElement != null) {
            var prevType = typeof prevElement;
            var nextType = typeof nextElement;
            if (prevType === 'string' || prevType === 'number') {
                return nextType === 'string' || nextType === 'number';
            } else {
                return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
            }
        }
        return false;
    };


    //文本组件
    function ReactDOMTextComponent(text) {
        //存下当前的字符串
        this._currentElement = '' + text;
        this._rootNodeID = null;
    }
    //component渲染时生成dom结构
    ReactDOMTextComponent.prototype.mountComponent = function (rootID) {
        this._rootNodeID = rootID;
        return '<span data-reactid="' + rootID + '">' + this._currentElement + '</span>';
    };

    //浏览器默认节点
    function ReactDOMComponent(element) {
        //存下当前的element对象引用
        this._currentElement = element;
        this._rootNodeID = null;
    }
    ReactDOMComponent.prototype.mountComponent = function (rootID) {
        //赋值标识
        this._rootNodeID = rootID;
        var props = this._currentElement.props;
        var tagOpen = '<' + this._currentElement.type;
        var tagClose = '</' + this._currentElement.type + '>';

        tagOpen += ' data-reactid=' + this._rootNodeID;

        //拼凑出属性
        for (var propKey in props) {

            //这里要做一下事件的监听，就是从属性props里面解析拿出on开头的事件属性的对应事件监听
            if (/^on[A-Za-z]/.test(propKey)) {
                var eventType = propKey.replace('on', '');
                //针对当前的节点添加事件代理,以_rootNodeID为命名空间
                $(document).delegate('[data-reactid="' + this._rootNodeID + '"]', eventType + '.' + this._rootNodeID, props[propKey]);
            }

            //对于children属性以及事件监听的属性不需要进行字符串拼接
            //事件会代理到全局。这边不能拼到dom上不然会产生原生的事件监听
            if (props[propKey] && propKey != 'children' && !/^on[A-Za-z]/.test(propKey)) {
                tagOpen += ' ' + propKey + '=' + props[propKey];
            }
        }

        //获取子节点渲染出的内容
        var content = '';

        var children = props.children || [];

        //用于保存所有的子节点的component实例，以后会用到
        var childrenInstances = [];
        var that = this;

        $.each(children, function (key, child) {
            //这里再次调用了instantiateReactComponent实例化子节点component类，拼接好返回
            var childComponentInstance = instantiateReactComponent(child);
            childComponentInstance._mountIndex = key;

            childrenInstances.push(childComponentInstance);
            //子节点的rootId是父节点的rootId加上新的key也就是顺序的值拼成的新值
            var curRootId = that._rootNodeID + '.' + key;
            //得到子节点的渲染内容
            var childMarkup = childComponentInstance.mountComponent(curRootId);
            //拼接在一起
            content += ' ' + childMarkup;
        });

        //留给以后更新时用的，这边先不用管
        this._renderedChildren = childrenInstances;

        return tagOpen + '>' + content + tagClose;

    };

    function ReactCompositeComponent(element) {
        //存放元素的element对象
        this._currentElement = element;
        //存放唯一标识
        this._rootNodeID = null;
        //存放对应的ReactClass实例
        this._instance = null;
    }

    ReactCompositeComponent.prototype.mountComponent = function (rootID) {
        this._rootNodeID = rootID;
        //拿到当前元素的属性值
        var publicProps = this._currentElement.props;
        //拿到对应的ReactClass
        var ReactClass = this._currentElement.type;
        //初始化
        var inst = new ReactClass(publicProps);

        this._instance = inst;

        //保留对当前component的引用，下面更新会用到
        inst._reactInternalInstance = this;

        if (inst.componentWillMount) {
            inst.componentWillMount();
            //这里在原始的reactjs其实还有一层处理，就是  componentWillMount调用setstate，不会触发rerender而是自动提前合并，这里为了保持简单，就略去了
        }

        //调用ReactClass实例的render方法，返回一个element或者一个文本节点
        var renderedElement = this._instance.render();
        //得到renderedElement对应的component类实例
        var renderedComponentInstance = instantiateReactComponent(renderedElement);

        this._renderedComponent = renderedComponentInstance;//存起来留作后用

        //拿到渲染之后的字符串内容，讲当前的_rootNodeID传给render出的节点
        var renderedMarup = renderedComponentInstance.mountComponent(this._rootNodeID);

        $(document).on('mountReady', function () {
            inst.componentDidMount && inst.componentDidMount();
        });

        return renderedMarup;
    };
    ReactCompositeComponent.prototype.receiveComponent = function (nextElement, newState) {

        /**
         *
         * 不要被这么多代码吓到，其实流程很简单。
         * 它主要做了什么事呢？首先会合并改动，
         * 生成最新的state,props然后拿以前的render返回的element跟现在最新调用render生成的element进行对比（_shouldUpdateReactComponent），
         * 看看需不需要更新，如果要更新就继续调用对应的component类对应的receiveComponent就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。
         * 当然还有种情况是，两次生成的element差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就o了
         *
         */


        //如果接受了新的，就使用最新的element
        this._currentElement=nextElement || this._currentElement;

        var inst=this._instance;

        /**
         * 要记住，一个组件，即ReactCompositeComponent实例
         * 会引用一个ReactClass实例，保存在this._instance中
         * 会引用一个ReactElement实例，保存在this._currentElement中
         *
         * 至于ReactElement与ReactClass的关系也很简单
         * ReactElement的type引用ReactClass的构造函数
         */

        //合并state
        var nextState= $.extend(inst.state,newState);
        var nextProps=this._currentElement.props;

        //改写state
        inst.state=nextState;

        //如果inst有shouldComponentUpdate并且返回false。说明组件本身判断不要更新，就直接返回。
        if(inst.shouldComponentUpdate && (inst.shouldComponentUpdate(nextProps,nextState)===false)){
            return;
        }

        var prevComponentInstance=this._renderedComponent;
        var prevRenderedElement=prevComponentInstance._currentElement;
        //重新执行render拿到对应的新element;
        var nextRenderedElement=this._instance.render();

        //判断是需要更新还是直接就重新渲染
        //注意，这里的_shouldUpdateReactComponent跟上面的不同哦，这个是全局的方法
        if(_shouldUpdateReactComponent(prevRenderedElement,nextRenderedElement)){
            //如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element，更新子节点
            prevComponentInstance.receiveComponent(nextRenderedElement);
            //调用componentDidUpdate表示更新完了
            inst.componentDidUpdate && inst.componentDidUpdate();
        }else{
            //如果发现完全是不同的两种element，那就干脆重新渲染了
            var thisID=this._rootNodeID;
            //重新new一个对应的component
            this._renderedComponent=this._instantiateReactComponent(nextRenderedElement);
            //重新生成对应的元素内容
            var nextMarkup=this._renderedComponent.mountComponent(thisID);
            //替换整个节点
            $('[data-reactid="' + this._rootNodeID + '"]').replaceWith(nextMarkup);
        }
    };



    //component工厂 用来返回一个component实例
    function instantiateReactComponent(node) {
        //文本节点
        if (typeof node === 'string' || typeof node === 'number') {
            return new ReactDOMTextComponent(node);
        }
        //浏览器默认节点
        if (typeof node === 'object' && typeof node.type === 'string') {
            //注意这里使用了一种新的component;
            return new ReactDOMComponent(node);
        }
        //自定义的元素节点
        if (typeof node === 'object' && typeof node.type === 'function') {
            //注意这里，使用新的component,专门针对自定义元素
            return new ReactCompositeComponent(node);
        }
    }

    //ReactElement就是虚拟dom的概念，具有一个type属性代表当前的节点类型，还有节点的属性props
    //比如对于div这样的节点type就是div，props就是那些attributes
    //另外这里的key,可以用来标识这个element，用于优化以后的更新，这里可以先不管，知道有这么个东西就好了
    function ReactElement(type, key, props) {
        this.type = type;
        this.key = key;
        this.props = props;
    }


    //定义超级父类
    var ReactClass = function () {
    };
    //留给子类去继承覆盖
    ReactClass.prototype.render = function () {
    };

    ReactClass.prototype.setState = function (newState) {
        //还记得我们在ReactCompositeComponent里面mount的时候 做了赋值
        //所以这里可以拿到 对应的ReactCompositeComponent的实例_reactInternalInstance
        this._reactInternalInstance.receiveComponent(null, newState);
        //可以看到setState主要调用了对应的component的receiveComponent来实现更新。所有的挂载，更新都应该交给对应的component来管理。
        //就像所有的component都实现了mountComponent来处理第一次渲染，所有的componet类都应该实现receiveComponent用来处理自己的更新
    };

    React = {
        nextReactRootIndex: 0,
        createClass: function (spec) {
            //返回子类的构造函数

            var Constructor = function (props) {
                this.props = props;
                this.state = this.getInitialState() ? this.getInitialState() : null;
            };

            //原型继承，继承超级父类
            Constructor.prototype = new ReactClass();
            Constructor.prototype.constructor = Constructor;

            $.extend(Constructor.prototype, spec);

            return Constructor;

        },
        //createElement只是做了简单的参数修正，最终返回一个ReactElement实例对象也就是我们说的虚拟元素的实例。
        createElement: function (type, config, children) {
            var props = {}, propName;
            config = config || {};
            //看有没有key，用来标识element的类型，方便以后高效的更新，这里可以先不管
            var key = config.key || null;

            //复制config里的内容到props
            for (propName in config) {
                if (config.hasOwnProperty(propName) && propName !== 'key') {
                    props[propName] = config[propName];
                }
            }

            //处理children,全部挂载到props的children属性上
            //支持两种写法，如果只有一个参数，直接赋值给children，否则做合并处理
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
                props.children = $.isArray(children) ? children : [children];
            } else if (childrenLength > 1) {
                var childArray = Array(childrenLength);
                for (var i = 0; i < childrenLength; i++) {
                    childArray[i] = arguments[i + 2];
                }
                props.children = childArray;
            }
            return new ReactElement(type, key, props);// 返回虚拟元素
        },
        render: function (element, container) {
            //将虚拟dom转换成ReactComponent.
            var componentInstance = instantiateReactComponent(element);
            //生成html标记
            var markup = componentInstance.mountComponent(React.nextReactRootIndex++);
            $(container).html(markup);
            //触发完成mount的事件
            $(document).trigger('mountReady');
        }
    };
</script>
</body>
</html>